# ğŸ“Œ Sorting

## ğŸ“Œ [ìˆ˜ ì •ë ¬í•˜ê¸°](https://www.acmicpc.net/problem/2750) 

### [2750]()

* í•µì‹¬
```
ì„ íƒì •ë ¬ì„ ì´ìš©í•œ ì…ë ¥ë°›ì€ ìˆ«ì ì˜¤ë¦„ì°¨ìˆœ ì •ë¦¬ ì¶œë ¥
```
> [ì„ íƒì •ë ¬](https://github.com/Ejaeda/42_study/tree/master/C/%5BSorting_Algorithms_in_C%5D)

* ì„ íƒì •ë ¬ì½”ë“œ
```.c
void    check(int arr[], int N){
    int min, temp;

    for(int idx = 0; idx < N-1; idx++){
        min = idx;
        for(int idx2 = idx + 1; idx2 < N; idx2++){
            if(arr[min] > arr[idx2])
                min = idx2;
        }
        temp = arr[idx];
        arr[idx] = arr[min];
        arr[min] = temp;
    }
    for(int idx = 0; idx < N; idx++){
        printf("%d\n", arr[idx]);
    }
}
```
-----

## ğŸ“Œ [ì¢Œí‘œ ì •ë ¬í•˜ê¸°](https://www.acmicpc.net/problem/11650) 

### [11650]()

* í•µì‹¬
```
ì‹œê°„ì œí•œ 1ì´ˆëŠ” mergesort ë¼ê³  ìƒê°í•˜ì
```
> [ë³‘í•©ì •ë ¬](https://github.com/Ejaeda/C_lang/blob/master/C-DataStructure/Ch10.Sorting/File/MergeSort.c)

* ë³‘í•©ì •ë ¬( + êµ¬ì¡°ì²´)ì½”ë“œ
```.c
    while(fIdx<=mid && rIdx<=right)
    {
        if(p[fIdx].x < p[rIdx].x)
            sortArr[sIdx] = p[fIdx++];
        else if(p[fIdx].x > p[rIdx].x)
            sortArr[sIdx] = p[rIdx++];
        else
        {
            if(p[fIdx].y < p[rIdx].y)
                sortArr[sIdx] = p[fIdx++];
            else if(p[fIdx].y > p[rIdx].y)
                sortArr[sIdx] = p[rIdx++];
        }
        sIdx++;
    }
```
- ğŸ“Œ ìƒˆë¡œ ì•ˆ ì‚¬ì‹¤

1.  êµ¬ì¡°ì²´ ë³‘í•©ì •ë ¬

> êµ¬ì¡°ì²´ì˜ ë©¤ë²„ê°€ 2ê°œì¼ë•Œ ì´ë¥¼ ë¹„êµí•˜ëŠ” ì½”ë“œ

-----

## ğŸ“Œ [ë‚˜ì´ìˆœ ì •ë ¬](https://www.acmicpc.net/problem/10814) 

### [10814]()

- í•µì‹¬
```.c
1. ë‚˜ì´ì™€ ì´ë¦„ì„ ì…ë ¥ë°›ê¸°
2. ë‚˜ì´ìˆœ, ë‚˜ì´ê°™ë‹¤ë©´ ì…ë ¥ë°›ì€ ìˆœìœ¼ë¡œ ì¶œë ¥í•˜ê¸°
```

- ë¬¸ì œì ‘ê·¼
```.c
1. ë‚˜ì´ì™€ ì´ë¦„ì„ í•¨ê»˜ ì…ë ¥ë°›ì•„ì•¼ í•˜ë¯€ë¡œ êµ¬ì¡°ì²´
2. ë‚˜ì´ ì •ë ¬ì„ ìœ„í•´ quick sort
```

- ì½”ë“œ êµ¬í˜„

êµ¬ì¡°ì²´ ì„ ì–¸
```.c
    typedef struct _member
    {
        int age;
        char name[101];
    } member

    
            ...
```

```.c

int compare(const void* a, const void* b)
{
    return (a->age > b->age ? 1 : a->age < b->age ? -1 : 0);
}

int main()
{
    ...

qsort(list, N, sizeof(list[0]), compare);

    ...
}
```
        

- ğŸ“Œ ìƒˆë¡œ ì•ˆ ì‚¬ì‹¤

1.  êµ¬ì¡°ì²´ ì ‘ê·¼

> list.a == (&list)->a

```.c
    member *list;

    list = malloc( ... );
    // êµ¬ì¡°ì²´ ìë£Œí˜• listë¥¼ 2ì°¨ì› ë°°ì—´ì²˜ëŸ¼ ë§ì´ ë§Œë“¤ì—ˆë‹¤

    scanf(" %d %s", &list[idx].age, list[idx].name)
    // list ëŠ” member * í˜•ìœ¼ë¡œ ì£¼ì†Œì§€ë§Œ, ê°œê°œì¸ì˜ 
    // list[idx]ë¡œ ì ‘ê·¼í•˜ê³  ìˆì–´ list[idx].name ë¡œ ì ‘ê·¼í•´ì•¼í•¨

    // &list[p]idx].age << & ë¶™ì´ëŠ” ìœ„ì¹˜ë„ ì˜ ë³´ì
```

2. í€µì†ŒíŠ¸ ë‚´ë¶€ í•¨ìˆ˜ ì“°ê¸°

```.c
void qsort
(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
```
Parameters

1. base

    ì •ë ¬í•  ë°°ì—´ì˜ ì²« ë²ˆì§¸ ìš”ì†Œì— ëŒ€í•œ í¬ì¸í„°

2. nitems

    ë² ì´ìŠ¤ë¡œ ê°€ë¦¬í‚¨ ë°°ì—´ì˜ ìš”ì†Œ ìˆ˜

3. size

    ë°°ì—´ì— í¬í•¨ëœ ê° ìš”ì†Œì˜ í¬ê¸°(ë°”ì´íŠ¸)

4. compar

    ë‘ ìš”ì†Œë¥¼ ë¹„êµí•˜ëŠ” í•¨ìˆ˜


-   compare í•¨ìˆ˜ êµ¬í˜„í•  ë•Œ

    ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ êµ¬í˜„í•˜ê³  ì‹¶ì„ ë•Œ í° ìˆ˜ ë¶€í„° 1, 0, -1 ê°’ì„ ë°˜í™˜
    
    ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ êµ¬í˜„í•˜ê³  ì‹¶ì„ ë•Œ í° ìˆ˜ ë¶€í„° -1, 0, 1 ê°’ì„ ë°˜í™˜

3. ì‚¼í•­ì—°ì‚°ì ì‘ìš©

```.c
return (a->age > b->age ? 1 : a->age < b->age ? -1 : 0);
```
-----


