# ğŸ“Œ Sorting

## ğŸ“Œ [ìˆ˜ ì •ë ¬í•˜ê¸°](https://www.acmicpc.net/problem/2750) 

### [2750]()

* í•µì‹¬
```
ì„ íƒì •ë ¬ì„ ì´ìš©í•œ ì…ë ¥ë°›ì€ ìˆ«ì ì˜¤ë¦„ì°¨ìˆœ ì •ë¦¬ ì¶œë ¥
```
> [ì„ íƒì •ë ¬](https://github.com/Ejaeda/42_study/tree/master/C/%5BSorting_Algorithms_in_C%5D)

* ì„ íƒì •ë ¬ì½”ë“œ
```.c
void    check(int arr[], int N){
    int min, temp;

    for(int idx = 0; idx < N-1; idx++){
        min = idx;
        for(int idx2 = idx + 1; idx2 < N; idx2++){
            if(arr[min] > arr[idx2])
                min = idx2;
        }
        temp = arr[idx];
        arr[idx] = arr[min];
        arr[min] = temp;
    }
    for(int idx = 0; idx < N; idx++){
        printf("%d\n", arr[idx]);
    }
}
```
-----

## ğŸ“Œ [ìˆ˜ ì •ë ¬í•˜ê¸°3](https://www.acmicpc.net/problem/10989) 

### [10989]()

* í•µì‹¬
```
counting sort
```
> [counting sort](https://bowbowbow.tistory.com/8)

1. ìœ„ í˜ì´ì§€ëŒ€ë¡œ í•˜ë‚˜ì”© êµ¬í˜„í•˜ë‹ˆ ë©”ëª¨ë¦¬ ì´ˆê³¼ ë° ì‹œê°„ ì´ˆê³¼ ë°œìƒ

    ëˆ„ì  ì¹´ìš´íŒ…ì— ë”°ë¥¸ ê²°ê³¼ë¥¼ ë°°ì—´ì— ì €ì¥í•˜ê³  ì¶œë ¥í•˜ì˜€ìŒ

2. ë°°ì—´ì€ ì¹´ìš´íŒ… count[]ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ëŠ”ã„´ ê°„ë‹¨í•œ ë³€ìˆ˜ë¡œ ëŒ€ì²´

    - ìˆ«ìë¥¼ ë³€ìˆ˜ë¡œ ì…ë ¥ë°›ì•„ í•´ë‹¹ ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ count[ì…ë ¥ ê°’]ì„ ì¦ê°€

    - cnt ê°’ì´ 0ì´ ì•„ë‹ ë•Œ, cnt ê°’ ë§Œí¼ ì¶œë ¥

- ğŸ“Œ ìƒˆë¡œ ì•ˆ ì‚¬ì‹¤

1.  counting sort

    ì›ë˜ ì¼ë°˜ì ì¸ ì½”ë“œ
    > [amination](https://www.cs.miami.edu/home/burt/learning/Csc517.091/workbook/countingsort.html)
```c
#include <stdio.h>

#define max 10001

int main()
{
    int N;
    int num[1000001] = {0};
    int visit[1000001] = {0};
    int count[max] = {0};
    int count_sum[max] = {0};

    scanf("%d", &N);

    int idx = 0;
    while (++idx <= N)
    {
        scanf("%d", &num[idx]);
        count[num[idx]]++;
    }
    count_sum[0] = count[0];
    idx = 0;
    while (++idx < max)
        count_sum[idx] = count_sum[idx - 1] + count[idx];

    idx = N+1;
    while (--idx >= 1)
    {
        visit[count_sum[num[idx]]] = num[idx];
        count_sum[num[idx]]--;
    }

    idx = 0;
    while (++idx <= N)
        printf("%d\n", visit[idx]);
}
```
- ì¹´ìš´íŒ… ì†ŒíŠ¸ëŠ” ìˆ˜ê°€ ì–¼ë§Œí¼ ë‚˜ì™”ëŠ”ì§€ë¥¼ ì„¸ê³  ê·¸ë§Œí¼ ìˆœì„œëŒ€ë¡œ ì¶œë ¥

    ë‹¨ìˆœ 10000ê°œì˜ ìˆ«ìë¥¼ ì¶œë ¥í•˜ë¯€ë¡œ ë©”ëª¨ë¦¬ í¬ê¸°ê°€ 8MB ë§Œìœ¼ë¡œë„ ê°€ëŠ¥!
    
-----

## ğŸ“Œ [ì¢Œí‘œ ì •ë ¬í•˜ê¸°](https://www.acmicpc.net/problem/11650) 

### [11650]()

* í•µì‹¬
```
ì‹œê°„ì œí•œ 1ì´ˆëŠ” mergesort ë¼ê³  ìƒê°í•˜ì
```
> [ë³‘í•©ì •ë ¬](https://github.com/Ejaeda/C_lang/blob/master/C-DataStructure/Ch10.Sorting/File/MergeSort.c)

* ë³‘í•©ì •ë ¬( + êµ¬ì¡°ì²´)ì½”ë“œ
```.c
    while(fIdx<=mid && rIdx<=right)
    {
        if(p[fIdx].x < p[rIdx].x)
            sortArr[sIdx] = p[fIdx++];
        else if(p[fIdx].x > p[rIdx].x)
            sortArr[sIdx] = p[rIdx++];
        else
        {
            if(p[fIdx].y < p[rIdx].y)
                sortArr[sIdx] = p[fIdx++];
            else if(p[fIdx].y > p[rIdx].y)
                sortArr[sIdx] = p[rIdx++];
        }
        sIdx++;
    }
```
- ğŸ“Œ ìƒˆë¡œ ì•ˆ ì‚¬ì‹¤

1.  êµ¬ì¡°ì²´ ë³‘í•©ì •ë ¬

> êµ¬ì¡°ì²´ì˜ ë©¤ë²„ê°€ 2ê°œì¼ë•Œ ì´ë¥¼ ë¹„êµí•˜ëŠ” ì½”ë“œ

-----

## ğŸ“Œ [ë‚˜ì´ìˆœ ì •ë ¬](https://www.acmicpc.net/problem/10814) 

### [10814]()

- í•µì‹¬
```.c
1. ë‚˜ì´ì™€ ì´ë¦„ì„ ì…ë ¥ë°›ê¸°
2. ë‚˜ì´ìˆœ, ë‚˜ì´ê°™ë‹¤ë©´ ì…ë ¥ë°›ì€ ìˆœìœ¼ë¡œ ì¶œë ¥í•˜ê¸°
```

- ë¬¸ì œì ‘ê·¼
```.c
1. ë‚˜ì´ì™€ ì´ë¦„ì„ í•¨ê»˜ ì…ë ¥ë°›ì•„ì•¼ í•˜ë¯€ë¡œ êµ¬ì¡°ì²´
2. ë‚˜ì´ ì •ë ¬ì„ ìœ„í•´ quick sort
```

- ì½”ë“œ êµ¬í˜„

êµ¬ì¡°ì²´ ì„ ì–¸
```.c
    typedef struct _member
    {
        int age;
        char name[101];
    } member

    
            ...
```

```.c

int compare(const void* a, const void* b)
{
    return (a->age > b->age ? 1 : a->age < b->age ? -1 : 0);
}

int main()
{
    ...

qsort(list, N, sizeof(list[0]), compare);

    ...
}
```
        

- ğŸ“Œ ìƒˆë¡œ ì•ˆ ì‚¬ì‹¤

1.  êµ¬ì¡°ì²´ ì ‘ê·¼

> list.a == (&list)->a

```.c
    member *list;

    list = malloc( ... );
    // êµ¬ì¡°ì²´ ìë£Œí˜• listë¥¼ 2ì°¨ì› ë°°ì—´ì²˜ëŸ¼ ë§ì´ ë§Œë“¤ì—ˆë‹¤

    scanf(" %d %s", &list[idx].age, list[idx].name)
    // list ëŠ” member * í˜•ìœ¼ë¡œ ì£¼ì†Œì§€ë§Œ, ê°œê°œì¸ì˜ 
    // list[idx]ë¡œ ì ‘ê·¼í•˜ê³  ìˆì–´ list[idx].name ë¡œ ì ‘ê·¼í•´ì•¼í•¨

    // &list[p]idx].age << & ë¶™ì´ëŠ” ìœ„ì¹˜ë„ ì˜ ë³´ì
```

2. í€µì†ŒíŠ¸ ë‚´ë¶€ í•¨ìˆ˜ ì“°ê¸°

```.c
void qsort
(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
```
Parameters

1. base

    ì •ë ¬í•  ë°°ì—´ì˜ ì²« ë²ˆì§¸ ìš”ì†Œì— ëŒ€í•œ í¬ì¸í„°

2. nitems

    ë² ì´ìŠ¤ë¡œ ê°€ë¦¬í‚¨ ë°°ì—´ì˜ ìš”ì†Œ ìˆ˜

3. size

    ë°°ì—´ì— í¬í•¨ëœ ê° ìš”ì†Œì˜ í¬ê¸°(ë°”ì´íŠ¸)

4. compar

    ë‘ ìš”ì†Œë¥¼ ë¹„êµí•˜ëŠ” í•¨ìˆ˜


-   compare í•¨ìˆ˜ êµ¬í˜„í•  ë•Œ

    ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ êµ¬í˜„í•˜ê³  ì‹¶ì„ ë•Œ í° ìˆ˜ ë¶€í„° 1, 0, -1 ê°’ì„ ë°˜í™˜
    
    ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ êµ¬í˜„í•˜ê³  ì‹¶ì„ ë•Œ í° ìˆ˜ ë¶€í„° -1, 0, 1 ê°’ì„ ë°˜í™˜

3. ì‚¼í•­ì—°ì‚°ì ì‘ìš©

```.c
return (a->age > b->age ? 1 : a->age < b->age ? -1 : 0);
```
-----


